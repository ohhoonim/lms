# 인사정보 동기화

매우 중요한 부분입니다. 미리 가져온 변경사항을 관리하기 위해서는 별도의 임시 저장소(Staging Area) 개념이 필요합니다. 기존 사용자 엔티티에 직접 변경사항을 덮어쓰지 않고, 적용 시점까지 별도의 스키마에 보관하는 것이 데이터 무결성과 관리의 유연성을 보장하는 가장 좋은 방법입니다.

이러한 접근 방식을 위한 스키마 설계와 그 필요성에 대해 자세히 설명해 드릴게요.

임시 변경사항(Pending Changes) 스키마 설계의 필요성
기존 User 테이블에 effectiveDate 속성만 추가하고 변경될 필드(예: department)를 함께 저장하면 다음과 같은 문제가 발생할 수 있습니다.

데이터 오염: 변경 예정인 정보(예: '총무팀')가 현재 사용 중인 정보('인사팀')와 같은 필드에 혼재되어 혼란을 야기할 수 있습니다.

다중 변경사항 관리의 어려움: 한 사용자에 대해 여러 개의 변경사항(예: 부서 변경과 직위 변경)이 동시에 예정되어 있다면, 이를 하나의 행에 모두 담기 어렵습니다.

변경 이력 관리의 복잡성: 변경이 적용된 후 이전 정보를 복구하거나 변경 이력을 추적하기가 매우 어려워집니다.

이러한 문제를 해결하기 위해, 다음과 같은 별도의 스키마를 설계하는 것이 효과적입니다.

비즈니스 도메인 엔티티 (변경 예정 항목)
1. 변경 예정 내역 (PendingChange)
이 엔티티는 사용자에 대한 변경 예정 내역 자체를 기록합니다.

pendingChangeId: 변경 내역 고유 식별자 (PK)

userId: 대상 사용자 (FK)

changeType: 변경 유형 (department_change, job_title_change 등)

effectiveDate: 변경이 적용될 시점

status: 변경 내역의 상태 (pending, applied, cancelled)

createdAt: 변경 내역이 생성된 시각

2. 변경 상세 정보 (ChangeDetail)
이 엔티티는 PendingChange에 대한 구체적인 변경 내용을 담고 있습니다. 예를 들어, department_change라는 변경 내역에 대한 실제 변경 전/후 값이 여기에 기록됩니다.

changeDetailId: 변경 상세 정보 고유 식별자 (PK)

pendingChangeId: 변경 내역 (FK)

attributeName: 변경될 속성 이름 (department, jobTitle 등)

oldValue: 변경 전 값 (인사팀, 팀원 등)

newValue: 변경 후 값 (총무팀, 팀장 등)

스키마를 활용한 프로세스
새로운 스키마를 적용하면 '계정 일괄 수정' 유스케이스는 다음과 같이 진행됩니다.

데이터 수신: 인사 시스템에서 변경된 사용자 정보를 가져와서 PendingChange 및 ChangeDetail 테이블에 저장합니다. 이때 effectiveDate는 9월 2일로 설정됩니다.

정기 작업 실행: 시스템은 매일/매시간 배치 작업을 통해 PendingChange 테이블을 확인합니다.

적용 시점 확인: 현재 시각이 effectiveDate를 지났고, 상태가 pending인 모든 변경 내역을 찾습니다.

정보 반영: 해당 변경 내역을 바탕으로 User 테이블의 실제 사용자 정보를 업데이트합니다.

상태 변경: 업데이트가 완료되면 PendingChange의 status를 applied로 변경합니다.

이렇게 하면 User 테이블은 항상 현재 상태의 최신 데이터를 유지할 수 있으며, 변경 예정 정보는 PendingChange와 ChangeDetail 테이블에 깔끔하게 분리되어 관리됩니다.

이 방식은 단순히 untilLock 필드 하나로 해결하는 것보다 더 견고하고 확장 가능한 시스템을 만듭니다. 나중에 새로운 변경 유형(예: 직책 변경)이 추가되더라도, attributeName과 oldValue, newValue 필드를 활용하여 유연하게 대처할 수 있습니다.